<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-other2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-other2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06｜怎么支持条件语句和循环语句？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></span><span>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></span><span>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></li><li>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></li><li>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词">01.开篇词</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/01"><span>开篇词｜让我们来写一门计算机语言吧</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/02"><span>课前热身｜开始学习之前我们要准备什么？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来">02.起步篇让一门超简单的语言跑起来</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/01"><span>01｜实现一门超简单的语言最快需要多久？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/02"><span>02｜词法分析：识别Token也可以很简单吗？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/03"><span>03｜支持表达式：解析表达式和解析语句有什么不同？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/04"><span>04｜如何让我们的语言支持变量和类型？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/05"><span>05｜函数实现：是时候让我们的语言支持函数和返回值了</span></a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06"><span>06｜怎么支持条件语句和循环语句？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/07"><span>07｜怎么设计属于我们自己的虚拟机和字节码？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08"><span>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/09"><span>09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/10"><span>10｜基于C语言的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/11"><span>11｜基于C语言的虚拟机（二）：性能增长10倍的秘密</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/12"><span>12｜物理机上程序运行的硬件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/13"><span>13｜物理机上程序运行的软件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/14"><span>14｜汇编代码学习（一）：熟悉CPU架构和指令集</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/15"><span>15｜汇编语言学习（二）：熟悉X86汇编代码</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/16"><span>16｜生成本地代码第1关：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/17"><span>17｜生成本地代码第2关：变量存储、函数调用和栈帧维护</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/18"><span>18｜生成本地代码第3关：实现完整的功能</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/19"><span>19｜怎么实现一个更好的寄存器分配算法：原理篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/20"><span>20｜怎么实现一个更好的寄存器分配算法：实现篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/21"><span>21｜加深对栈的理解：实现尾递归和尾调用优化</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试">03.期中测试</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试/01"><span>期中测试｜快来检验你在起步篇的学习成果吧</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享">04.用户分享</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享/01"><span>“他山之石”｜Sugar：这门课你可以试试这么学</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐">05.不定时加餐</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐/01"><span>“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用">06.进阶篇让我们的语言更实用</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/01"><span>22｜增强编译器前端功能第1步：再识数据流分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/02"><span>23｜增强编译器前端功能第2步：增强类型体系</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03"><span>24｜增强编译器前端功能第3步：全面的集合运算</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/04"><span>25｜增强编译器前端功能第4步：综合运用多种语义分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/05"><span>26｜增强更丰富的类型第1步：如何支持浮点数？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/06"><span>27｜增加更丰富的类型第2步：如何支持字符串？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/07"><span>28｜增加更丰富的类型第3步：支持数组</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/08"><span>29｜面向对象编程第1步：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/09"><span>30｜面向对象编程第2步：剖析一些技术细节</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/10"><span>31｜面向对象编程第3步：支持继承和多态</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/11"><span>32｜函数式编程第1关：实现高阶函数</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/12"><span>33｜函数式编程第2关：实现闭包特性</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/13"><span>34｜内存管理第1关：Arena技术和元数据</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/14"><span>35｜内存管理第2关：实现垃圾回收</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高">07.优化篇让程序的性能更高</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/01"><span>36｜节点之海：怎么生成基于图的IR？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/02"><span>37 | 从AST到IR：体会数据流和控制流思维</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/03"><span>38｜中端优化第1关：实现多种本地优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/04"><span>39｜中端优化第2关：全局优化要怎么搞？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/05"><span>40｜中端优化第3关：一起来挑战过程间优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/06"><span>41｜后端优化：生成LIR和指令选择</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途">08.展望篇实现自主语言的征途</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/01"><span>42｜到这里，我们的收获和未尽的工作有哪些？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/02"><span>期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语">09.结束语</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语/01"><span>结束语｜等待你大展身手的那些领域</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/summary">手把手带你写一门编程语言</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="语法分析：支持一元表达式" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#语法分析支持一元表达式"><span>语法分析：支持一元表达式</span></a></li><li title="语义分析：深化对作用域的理解" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#语义分析深化对作用域的理解"><span>语义分析：深化对作用域的理解</span></a></li><li title="升级解释器" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#升级解释器"><span>升级解释器</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#课程小结"><span>课程小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#思考题"><span>思考题</span></a></li><li title="资源链接" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#资源链接"><span>资源链接</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06怎么支持条件语句和循环语句"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#06怎么支持条件语句和循环语句"><span class="icon icon-link"></span></a>06｜怎么支持条件语句和循环语句？</h1><p>你好，我是宫文学。</p><p>我们现在的语言已经支持表达式、变量和函数了。可是你发现没有，到现在为止，我们还没有支持流程控制类的语句，比如条件语句和循环语句。如果再加上这两类语句的话，我们的语言就能做很复杂的事情了，甚至你会觉得它已经是一门比较完整的语言了。</p><p>那么今天，我们就来加上条件语句和循环语句。在这个过程中，我们会加深对作用域和栈桢的理解，包括跨作用域的变量引用、词法作用域的概念，以及如何在运行时访问其他作用域的变量。这些知识点会帮助你加深对计算机语言的运行机制的理解。</p><p>而这些理解和认知，会有助于我们后面把基于AST的解释器升级成基于字节码的解释器，也有助于我们理解编译成机器码后的运行时机制。</p><p>好了，首先我们先从语法层面支持一下这两种语句。</p><h2 id="语法分析支持一元表达式"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#语法分析支持一元表达式"><span class="icon icon-link"></span></a>语法分析：支持一元表达式</h2><p>按照惯例，我们首先要写下新的语法规则，然后使用LL算法来升级语法分析程序。新的语法规则如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ifStatement</span></div><div class="token-line"><span class="token plain">        : If &#x27;(&#x27; expression &#x27;)&#x27; statement (Else statement)?</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    forStatement</span></div><div class="token-line"><span class="token plain">        :For &#x27;(&#x27; expression? &#x27;;&#x27; expression? &#x27;;&#x27; expression? &#x27;)&#x27; statement</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    statement:</span></div><div class="token-line"><span class="token plain">        : block</span></div><div class="token-line"><span class="token plain">        | functionDecl</span></div><div class="token-line"><span class="token plain">        | varaibleStatement</span></div><div class="token-line"><span class="token plain">        | expressionStatement</span></div><div class="token-line"><span class="token plain">        | returnStatement</span></div><div class="token-line"><span class="token plain">        | ifStatement</span></div><div class="token-line"><span class="token plain">        | forStatement</span></div><div class="token-line"><span class="token plain">        | emptyStatement</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>你从上面的语法可以得到这几个信息：</p><p>首先，if语句中，else部分是可选的。这样，我们在解析完if条件后面的语句以后，要去看看后面跟着的是不是’else’关键字，从而决定是否解析else后面的语句块。更具体的你可以参见<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L176">parseIfStatement函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的代码。</p><p>第二，在for循环语句中，for括号里用分号分割的三个表达式都是可选的，在解析的时候也要根据Follow集合来判断是否需要解析这三个表达式。这点你具体可以参见<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L223">parseForStatement函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的代码。</p><p>最后，从statement的语法规则中，我们也可以发现，我们的语言所支持的语句越来越多了，这也使得语言特性越来越丰富了。</p><p>现在，升级我们的语法解析程序，对你来说已经没有太大的困难了，你可以参照我的参考实现动手自己做一下。</p><p>不过，为了实现for语句，我们还有一个语言特性需要升级一下，这就是对一元运算的支持。</p><p>哪些是一元运算呢？比如，在for语句中，我们经常会使用下面的写法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for(i = 0; i&lt; 10; i++)</span></div></pre></div><p>其中i++就是使用了一元运算。在这里，为了方便，我们干脆就让程序支持所有的一元运算！</p><p>一元运算符除了++以外，还有–、~、!等。甚至还有更复杂一点的情况，+号和-号除了作为二元运算符以外，还可以作为一元运算符使用，比如下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">myAge = +myAge + -10;</span></div></pre></div><p>你甚至可以将多个一元运算符叠加使用，比如我们把上面的例子修改一下，仍然和原来的计算结果相同：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">myAge = + +myAge + - - -10;</span></div></pre></div><p>注意了，这里面的两个+号或两个-号之间是留有空格的，否则就会被词法分析程序识别成++和–了。</p><p>上面的示例程序有一些负数，比如-10。在这里，-10是一个表达式，由一个符号和一个字面量构成，而不是把-10整体上作为一个字面量。</p><p>在第二节介绍词法分析的时候，我曾经留了个思考题，问像-3这样的负数，是识别成-号和3，还是把-3整体作为一个Token识别出来？</p><p>答案是前者。原因是，如果不这样处理，2-3这样的表达式就会识别错。在词法分析阶段，我们只需要把-号作为Token识别出来就行了，至于它是作为一元运算符还是二元运算符来使用，那就交给语法分析程序来处理吧！</p><p>为了支持一元运算，我们需要把与表达式相关的语法规则升级一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">expression: assignment;</span></div><div class="token-line"><span class="token plain">    assignment: binary (assignmentOp binary)* ;</span></div><div class="token-line"><span class="token plain">    binary: unary (binOp unary)* ;</span></div><div class="token-line"><span class="token plain">    unary: primary | prefixOp unary | primary postfixOp ;</span></div><div class="token-line"><span class="token plain">    primary: StringLiteral | DecimalLiteral | IntegerLiteral | functionCall | &#x27;(&#x27; expression &#x27;)&#x27; ;</span></div><div class="token-line"><span class="token plain">    prefixOp = &#x27;+&#x27; | &#x27;-&#x27; | &#x27;++&#x27; | &#x27;--&#x27; | &#x27;!&#x27; | &#x27;~&#x27;;</span></div><div class="token-line"><span class="token plain">    postfixOp = &#x27;++&#x27; | &#x27;--&#x27;;</span></div></pre></div><p>在我们升级后的语法规则中，二元表达式能够分解成一元表达式，而一元表达式，又分成下面这三种情况。</p><p>第一种情况下，一元表达式就是一个基础表达式。</p><p>第二种情况是一个右递归的语法规则，可以由一个前缀一元运算符再加一个一元表达式组成，所以我们前面的“+ +myage”的表达式是正确的。</p><p>第三种情况，是一个基础表达式后面再跟上后缀一元运算符。后缀一元运算只有++和–两个，并且是不允许递归的，也就是说，像“myage++ ++”这样的表达式就是错误的。</p><p>具体解析一元表达式的代码你可以参见<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/06/parser.ts#L747">parseUnary函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>我们可以试着用支持一元运算符的解析器解析下面的示例程序，这个示例程序中有很多个+号和-号，你第一眼看上去可能很难判断出它们分别属于哪个语法成分。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//示例代码：example_unary.ts</span></div><div class="token-line"><span class="token plain">    let myAge:number = 18;</span></div><div class="token-line"><span class="token plain">    myAge = + +myAge++ + - - -10;</span></div><div class="token-line"><span class="token plain">    println(&quot;myAge=&quot;+myAge);</span></div></pre></div><p>但基于我们的语法规则，我们的解析器能够准确地分析出每个+号或-号所属的语法成分。比如，对于第二个语句，我们的解析器输出的AST是下图这个样子的，其中1个+号属于加法表达式，有两个+号和3个-号的都属于前缀一元运算符，而++号则属于后缀运算符。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage99d69953723ddd7652a53a42972384258ed6.0fa6aea4.jpg" alt="图片"/></p><p>那到此为止，我们的语法分析功能就升级完毕了。接下来，我们顺着已经养成的习惯，继续来看看这两个语句在语义方面有没有带来新的内容。</p><h2 id="语义分析深化对作用域的理解"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#语义分析深化对作用域的理解"><span class="icon icon-link"></span></a>语义分析：深化对作用域的理解</h2><p>你会发现，在程序里用上if语句和for语句以后，一个直观的表现就是出现了很多的语句块，而这些语句块是能够影响作用域的。我们把这些语句块所构成的作用域，叫做<strong>块作用域</strong>。</p><p>在早期的JavaScript版本是不支持块作用域的，比如，在下面的程序中，我们在块的外面仍然可以访问变量i，并且打印出i的值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo(){</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            var i = 4;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        console.log(i);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    foo();</span></div></pre></div><p>但在ES6版本以后，JavaScript也支持了块作用域。你可以用let关键字在块中声明变量，这个变量的作用域仅限于当前块，如果从作用域外面访问，编译器就会报错。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo(){</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            let i = 4;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        console.log(i);   //报编译错误</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    foo();</span></div></pre></div><p>在这种情况下，即使是块中变量的名称与块外的变量名相同也没关系。你看，在下面这个示例程序中，if语句块中的myAge和外面的myAge就是两个不同的变量，甚至类型都不相同。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function bar() {</span></div><div class="token-line"><span class="token plain">        let myAge = 18;</span></div><div class="token-line"><span class="token plain">        if (myAge &lt; 30) {</span></div><div class="token-line"><span class="token plain">            let myAge = &#x27;&#x27;;</span></div><div class="token-line"><span class="token plain">            myAge = &#x27;young&#x27;;</span></div><div class="token-line"><span class="token plain">            console.log(&quot;myAge, inside: &quot; + myAge);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        console.log(&quot;myAge, outside: &quot; + myAge);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个程序是可以正常运行的，在if块的内部和外部，都可以正常的打印myAge的值，但使用的是两个不同作用域中的变量。</p><p>你也看到了，块作用域的机制使得我们在语句块中使用变量名称的时候可以更加自由，不用担心在块中声明的变量会影响到块外面，从而减少了程序出错的概率，也让程序员在书写逻辑的时候更加自由。</p><p>而且，上面的示例程序在编译过程中会形成下面这个Scope结构。你会看到，每个Block都形成了自己的作用域，所有这些作用域构成了一个树状结构。每个作用域，可以看到在该作用域中声明的符号，以及上面各级的符号，但看不到兄弟作用域和下级作用域的符号。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage90bb909ec4737444573f6497d812fab39bbb.bd150d00.jpg" alt="图片"/></p><p>你要注意，if语句的条件部分和if下面的块其实属于两个作用域。在if条件中的myAge变量，指的是外面的这个myAge，它是number型的，因此我们把它用在“myAge&lt;30”这样一个条件表达式里。</p><p>读到这里，你可能产生一个疑问：在语句块中，如果在声明新的myAge之前，是否也可以像在if的条件表达式里那样来使用外部的myAge变量呢？我们可以试一下，把程序改成下面的样子，看看会产生什么结果。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function bar() {</span></div><div class="token-line"><span class="token plain">        let myAge = 18;</span></div><div class="token-line"><span class="token plain">        if (myAge &lt; 30) {</span></div><div class="token-line"><span class="token plain">            myAge = 30;</span></div><div class="token-line"><span class="token plain">            let myAge = &#x27;&#x27;;</span></div><div class="token-line"><span class="token plain">            myAge = &#x27;young&#x27;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你会发现，如果我们用Typescript编译，编译器会报错，说块中的myAge在没有初始化的时候，就被访问了：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage5694566c472686675e49b5a2b4cccfef0794.e5014765.png" alt="图片"/></p><p>这个例子说明了，在TypeScript中，如果存在和外部同名的变量，那你只能引用块中声明的变量，是没有办法引用外部变量的，无论块中声明的变量的位置是靠前还是靠后。</p><p>那是不是所有的语言，对于块作用域都是这样规定的呢？不是的，你可以用不同的语言试验一下。</p><p>首先是Java语言。Java语言也支持块定义域，但不允许块中的变量与外部变量名称相同。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static int bar(){</span></div><div class="token-line"><span class="token plain">        int  myAge = 18;</span></div><div class="token-line"><span class="token plain">        if (myAge &lt; 30) {</span></div><div class="token-line"><span class="token plain">            string myAge = &quot;young&quot;; //错误：变量名称重复</span></div><div class="token-line"><span class="token plain">            int yourAge = 20;    //块中的变量</span></div><div class="token-line"><span class="token plain">        }     </span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            int yourAge = 10;    //第二个块中可以有同名的变量</span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        return myAge + yourAge;  //错误：找不到yourAge</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再看看C语言。C语言允许在块中声明新的变量名称之前，引用外部的变量，也就是说，上面的示例代码如果用C语言改写一下，也是完全合法的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void bar(){</span></div><div class="token-line"><span class="token plain">        int myAge = 18;</span></div><div class="token-line"><span class="token plain">        if (myAge &lt; 30) {</span></div><div class="token-line"><span class="token plain">            myAge = 30;      //给外层的myAge赋值</span></div><div class="token-line"><span class="token plain">            const char* myAge = &quot;young&quot;;  //新声明一个myAge</span></div><div class="token-line"><span class="token plain">            printf(&quot;myAge=%s\n&quot;,myAge);   //打印内层的myAge的值</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        printf(&quot;myAge=%d\n&quot;,myAge);       //打印外层的myAge的值</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么，对于你日常使用的语言，在块作用域的语义上有什么不同呢？你也可以分析一下。</p><p>按照这节课对作用域的剖析方法，下次你再见到一段代码的时候，你可以迅速在大脑中划分出清晰的作用域的范围，形成作用域的树。作为语言的实现者，你也会对语言的特性有更加清晰的了解，这算是你学习这门课的额外收获吧！</p><p>那么，上面这些不同语言对于作用域的不同规定，会如何影响到语义分析程序呢？我们来看一下。</p><p>在前面的课程中，我们做语义分析的时候，分成了清晰的两个阶段：Enter阶段是建立符号表，Resolve阶段是去做引用消解。如果存在块内外变量同名的情况，在块中的变量引用，都会指向在块中声明的变量。</p><p>这种处理方法，对于C语言是不行的。使用上述方法，会导致第一个myAge引用的变量出错。也就是说，我们在做引用消解的时候，必须考虑语句的顺序，要注意我们在块中声明同名称的myAge之前，引用的实际是块外面的变量。</p><p>这就导致为C语言编写引用消解的程序要更复杂一些，建立符号表的工作和引用消解的工作必须是针对每一条语句同步去进行的。随着对每一个语句的扫描，符号表逐渐建立起来后，引用消解时总是指向最近的那一个声明。</p><p>我们现在的处理方法，用来处理Java程序，其实也是行不通的。在Java的块里，虽然不允许变量跟外部变量重名，但也必须是先声明后使用，所以也只能一边建符号表，一边做引用消解，这样才能发现在声明之前使用变量的错误。</p><p>那么，我们现在的处理方法，针对TypeScript或JavaScript（指ES6以上的版本）是不是就没有问题了呢？</p><p>其实还是有问题的，现在的算法没有办法检查出myAge在声明在前就被引用的错误，并像在Node.js里运行那样报错。</p><p>那要如何解决这个问题呢？其实只要把问题分析清楚了，解决起来也不是太难。</p><p>在我们的语义分析程序中，我们先用Enter类对AST做了一遍遍历，把包括变量的每个符号都正确地加入到了符号表中，也就是由Scope形成的一个层次数据结构。接下来，我们用RefResolver类对AST再做一次遍历，来建立引用消解，但在这次遍历中，我们用了一个临时的数据结构，来保存当前已经声明了的变量。</p><p>这样做的目的，是在引用消解的时候，我们既要看该变量是否属于该作用域，又要看当前该变量是否被声明了。如果该变量不属于当前作用域，那么我们就去引用外部作用域中的变量；而如果该变量属于当前作用域，那它必须在变量声明之后才能使用。</p><p>比如，对于下面程序中的&quot;myAge = 30&quot;这一行，编译器会认为这个myAge是块中声明的那个string类型的myAge，而不是外部作用域中的myAge。同时，由于目前块中的myAge还没有声明，如果提前使用它是错误的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function bar() {</span></div><div class="token-line"><span class="token plain">        let myAge = 18;</span></div><div class="token-line"><span class="token plain">        if (myAge &lt; 30) {</span></div><div class="token-line"><span class="token plain">            myAge = 30;  //编译错误</span></div><div class="token-line"><span class="token plain">            let myAge = &#x27;&#x27;;</span></div><div class="token-line"><span class="token plain">            myAge = &#x27;young&#x27;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以画一张图来表现当编译器遍历到“myAge=30;”这个语句的时候，相关内部状态信息的情况，以及编译器是如何决策的。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagee68de6ca00082597ae94a836b2689432a98d.5c61a6ca.jpg" alt="图片"/></p><p>你看，在遍历AST的过程中，我们的语义分析程序会不断更新一个集合中的值，这个集合就是“已声明的变量”。同时，我们的语义分析程序还会知道当前作用域中变量的集合的值。对比这两个集合的值，程序就会发现那些在声明之间就被使用的变量，并报错。</p><p>这种随着程序的执行流程，去动态计算一些数据的值，并根据这些值来做分析的方法，叫做<strong>数流分析框架</strong>。数据流分析框架在做语义分析和代码优化的时候都很有用，我们后面还会见到它的更多用途。</p><p>好了，理解了原理，写代码就简单了，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/06/semantic.ts#L203">RefResolver类<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中我给出的示例代码。</p><p>不过，关于引用消解，我还要再补充两个语义规则，这两个规则我们也要在算法中有所体现：</p><p>第一，在TypeScript中，函数的声明和引用的顺序是不受限制的。也就是说，完全可以声明在后，使用在前。所以，在引用消解程序中，处理变量的消解算法和函数的消解的算法是不同的。</p><p>第二，在同一个作用域中，不可以有名称相同的符号，变量和函数的名称也不可以冲突。所以，我在Scope类的设计中，使用了一个以名称为key，以符号为value的Map对象来保存该作用域中的符号，就隐含了名称唯一的要求。</p><p>好了，关于语义分析工作，我们就到这里。接下来，我们继续完成这节课的工作，让我们目前的解释器也能支持if语句和for语句。</p><h2 id="升级解释器"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#升级解释器"><span class="icon icon-link"></span></a>升级解释器</h2><p>首先看if语句。在解释器里，我们实现了visitIfStatement()方法，用于执行if语句。你可以看看下面的这个示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * 执行if语句</span></div><div class="token-line"><span class="token plain">     * @param ifStmt </span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    visitIfStatement(ifStmt:IfStatement):any{</span></div><div class="token-line"><span class="token plain">        //计算条件</span></div><div class="token-line"><span class="token plain">        let conditionValue = this.needLeftValue(this.visit(ifStmt.condition));</span></div><div class="token-line"><span class="token plain">        //条件为真，则执行then部分</span></div><div class="token-line"><span class="token plain">        if (conditionValue){ </span></div><div class="token-line"><span class="token plain">            return this.visit(ifStmt.stmt);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //条件为false，则执行else部分</span></div><div class="token-line"><span class="token plain">        else if (ifStmt.elseStmt !=null){ </span></div><div class="token-line"><span class="token plain">            return this.visit(ifStmt.elseStmt);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个逻辑是很清晰的。首先我们来计算if条件的值，如果为真，则执行if后面的语句或语句块；如果为假，则执行else后面的语句或语句块。</p><p>实现for循环的思路也差不多，遵循for语句的语义来运行就行了，你可以参考下面的示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * 执行for语句</span></div><div class="token-line"><span class="token plain">     * @param forStmt </span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    visitForStatement(forStmt:ForStatement):any{</span></div><div class="token-line"><span class="token plain">        //执行init</span></div><div class="token-line"><span class="token plain">        if(forStmt.init !=null){</span></div><div class="token-line"><span class="token plain">            this.visit(forStmt.init);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //计算循环结束的条件</span></div><div class="token-line"><span class="token plain">        let notTerminate = forStmt.termination == null ? true : this.visit(forStmt.termination);</span></div><div class="token-line"><span class="token plain">        while(notTerminate){</span></div><div class="token-line"><span class="token plain">            //执行循环体</span></div><div class="token-line"><span class="token plain">            let retVal = this.visit(forStmt.stmt);</span></div><div class="token-line"><span class="token plain">            //处理循环体中的Return语句</span></div><div class="token-line"><span class="token plain">            if (typeof retVal == &#x27;object&#x27; &amp;&amp; ReturnValue.isReturnValue(retVal)){</span></div><div class="token-line"><span class="token plain">                // console.log(&quot;is ReturnValue!!&quot;)</span></div><div class="token-line"><span class="token plain">                return retVal;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //执行递增部分</span></div><div class="token-line"><span class="token plain">            if (forStmt.increment!=null){</span></div><div class="token-line"><span class="token plain">                this.visit(forStmt.increment);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //执行循环判断</span></div><div class="token-line"><span class="token plain">            notTerminate = forStmt.termination == null ? true : this.visit(forStmt.termination);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中，循环的初始化部分在一开始执行的，而且只执行一次，接着我们就要计算循环的终止条件。如果不满足终止条件，则开始进入循环。每次循环，首先执行循环体，然后执行递增部分的语句，最后再检查一遍循环退出条件。</p><p>你可以写几个例子来测试if语句和for循环语句是否能正确运行。在这里，我提供了一个计算斐波那契数列的示例程序给你参考：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function fibonacci(n:number):number{</span></div><div class="token-line"><span class="token plain">        if (n &lt;= 1){</span></div><div class="token-line"><span class="token plain">            return n;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            return fibonacci(n-1) + fibonacci(n-2);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for (let i:number = 0; i&lt; 32; i++){</span></div><div class="token-line"><span class="token plain">        println(fibonacci(i));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个程序不仅演示了if语句和for循环，还演示了函数的递归调用。运行这个程序，就会打印出一个斐波那契数列，如下图所示：<br/><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage9b819b9789a30a96f26714124649493f4581.665fd6ac.png" alt="图片"/></p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>好了，到这里我们今天这节课就讲完了，我们来简单回顾一下。</p><p>这节课我们增加了对流程控制类语句的支持。在支持了if语句和for循环语句之后，我们的语言特性已经很丰富了，我们已经可以用这些特性编写很复杂的程序了，比如生成斐波那契数列的示例程序。</p><p>在这个过程中，<strong>最重要的知识点是对块作用域的理解</strong>。不同的语言在块作用域上的特性是不同的，所以我们要采用不同的算法来做引用消解。</p><p>TypeScript允许在块中声明新的变量覆盖外部作用域中的变量，块中所有该名称的变量都会引用这个新变量，但必须先声明再使用。TS的这个特点，就要求我们的算法要采用数据流分析框架，在遍历AST的过程中，知道某个变量在当前代码的位置是否已经被声明过了。你先把数据流分析框架记住，它非常有用，我们后面还会有很多场景要用到它。</p><p>此外，我们为了支持For循环，还增加了对一元运算符的支持。像++和–这样的运算符，在求值和未来生成字节码方面都有一些特殊性，你可以多注意示例代码对它们的处理。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>今天的思考题，我想问一下，对于for循环语句来说，一般包含几层的作用域？为什么？你可以运行一个例子，看看打印出来的符号表的层次，验证一下你的想法，欢迎在留言区留言。</p><p>感谢你和我一起学习编程语言，也欢迎你将这门课分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p><h2 id="资源链接"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06#资源链接"><span class="icon icon-link"></span></a>资源链接</h2><p><a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/tree/master/06">这节课的示例代码在这里！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 16:52:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-other2/umi.2006439a.js"></script>
  </body>
</html>
