<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-other2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-other2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></span><span>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></span><span>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></li><li>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></li><li>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词">01.开篇词</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/01"><span>开篇词｜让我们来写一门计算机语言吧</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/02"><span>课前热身｜开始学习之前我们要准备什么？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来">02.起步篇让一门超简单的语言跑起来</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/01"><span>01｜实现一门超简单的语言最快需要多久？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/02"><span>02｜词法分析：识别Token也可以很简单吗？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/03"><span>03｜支持表达式：解析表达式和解析语句有什么不同？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/04"><span>04｜如何让我们的语言支持变量和类型？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/05"><span>05｜函数实现：是时候让我们的语言支持函数和返回值了</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06"><span>06｜怎么支持条件语句和循环语句？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/07"><span>07｜怎么设计属于我们自己的虚拟机和字节码？</span></a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08"><span>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/09"><span>09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/10"><span>10｜基于C语言的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/11"><span>11｜基于C语言的虚拟机（二）：性能增长10倍的秘密</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/12"><span>12｜物理机上程序运行的硬件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/13"><span>13｜物理机上程序运行的软件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/14"><span>14｜汇编代码学习（一）：熟悉CPU架构和指令集</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/15"><span>15｜汇编语言学习（二）：熟悉X86汇编代码</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/16"><span>16｜生成本地代码第1关：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/17"><span>17｜生成本地代码第2关：变量存储、函数调用和栈帧维护</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/18"><span>18｜生成本地代码第3关：实现完整的功能</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/19"><span>19｜怎么实现一个更好的寄存器分配算法：原理篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/20"><span>20｜怎么实现一个更好的寄存器分配算法：实现篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/21"><span>21｜加深对栈的理解：实现尾递归和尾调用优化</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试">03.期中测试</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试/01"><span>期中测试｜快来检验你在起步篇的学习成果吧</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享">04.用户分享</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享/01"><span>“他山之石”｜Sugar：这门课你可以试试这么学</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐">05.不定时加餐</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐/01"><span>“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用">06.进阶篇让我们的语言更实用</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/01"><span>22｜增强编译器前端功能第1步：再识数据流分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/02"><span>23｜增强编译器前端功能第2步：增强类型体系</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03"><span>24｜增强编译器前端功能第3步：全面的集合运算</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/04"><span>25｜增强编译器前端功能第4步：综合运用多种语义分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/05"><span>26｜增强更丰富的类型第1步：如何支持浮点数？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/06"><span>27｜增加更丰富的类型第2步：如何支持字符串？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/07"><span>28｜增加更丰富的类型第3步：支持数组</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/08"><span>29｜面向对象编程第1步：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/09"><span>30｜面向对象编程第2步：剖析一些技术细节</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/10"><span>31｜面向对象编程第3步：支持继承和多态</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/11"><span>32｜函数式编程第1关：实现高阶函数</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/12"><span>33｜函数式编程第2关：实现闭包特性</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/13"><span>34｜内存管理第1关：Arena技术和元数据</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/14"><span>35｜内存管理第2关：实现垃圾回收</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高">07.优化篇让程序的性能更高</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/01"><span>36｜节点之海：怎么生成基于图的IR？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/02"><span>37 | 从AST到IR：体会数据流和控制流思维</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/03"><span>38｜中端优化第1关：实现多种本地优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/04"><span>39｜中端优化第2关：全局优化要怎么搞？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/05"><span>40｜中端优化第3关：一起来挑战过程间优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/06"><span>41｜后端优化：生成LIR和指令选择</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途">08.展望篇实现自主语言的征途</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/01"><span>42｜到这里，我们的收获和未尽的工作有哪些？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/02"><span>期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语">09.结束语</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语/01"><span>结束语｜等待你大展身手的那些领域</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/summary">手把手带你写一门编程语言</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="“设计”字节码" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#设计字节码"><span>“设计”字节码</span></a></li><li title="生成字节码" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#生成字节码"><span>生成字节码</span></a></li><li title="实现一个TypeScript版本的虚拟机" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#实现一个typescript版本的虚拟机"><span>实现一个TypeScript版本的虚拟机</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#课程小结"><span>课程小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#思考题"><span>思考题</span></a></li><li title="课程资源" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#课程资源"><span>课程资源</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08基于typescript的虚拟机一实现一个简单的栈机"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#08基于typescript的虚拟机一实现一个简单的栈机"><span class="icon icon-link"></span></a>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机</h1><p>你好，我是宫文学。</p><p>上一节课，我们已经探讨了设计一个虚拟机所要考虑的那些因素，并做出了一些设计决策。那么今天这一节课，我们就来实现一个初级的虚拟机。</p><p>要实现这个初级虚拟机，具体来说，我们要完成下面三方面的工作：</p><p>首先，我们要设计一些字节码，来支持第一批语言特性，包括支持函数、变量和整型数据的运算。也就是说，我们的虚拟机要能够支持下面程序的正确运行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//一个简单的函数，把输入的参数加10，然后返回</span></div><div class="token-line"><span class="token plain">    function foo(x:number):number{</span></div><div class="token-line"><span class="token plain">        return x + 10;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //调用foo，并输出结果</span></div><div class="token-line"><span class="token plain">    println(foo(18));</span></div></pre></div><p>第二，我们要做一个字节码生成程序，基于当前的AST生成正确的字节码。</p><p>第三，使用TypeScript，实现一个虚拟机的原型系统，验证相关设计概念。</p><p>话不多说，开搞，让我们先设计一下字节码吧！</p><h2 id="设计字节码"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#设计字节码"><span class="icon icon-link"></span></a>“设计”字节码</h2><p>说是设计，其实我比较懒，更愿意抄袭现成的设计，比如Java的字节码设计。因为Java字节码的资料最充分，比较容易研究，不像V8等的字节码，只有很少的文档资料，探讨的人也很少。另外，学会手工生成Java字节码还有潜在的实用价值，比如你可以把自己的语言编译后直接在JVM上运行。那么我们就先来研究一下Java字节码的特点。</p><p>上面的用TypeScript编写的示例代码，如果用Java改写，会变成下面的程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//实现同样功能的Java程序。</span></div><div class="token-line"><span class="token plain">    public class A{</span></div><div class="token-line"><span class="token plain">        public static int foo(int a){</span></div><div class="token-line"><span class="token plain">            return a + 10;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public static void main(String args[]){</span></div><div class="token-line"><span class="token plain">            System.out.println(foo(8));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们首先把这个Java程序编译成字节码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">javac A.java</span></div></pre></div><p>这个文件是一个二进制文件。我们可以用hexdump命令查看它的内容。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">hexdump -C A.class</span></div></pre></div><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage192e19380b1b13c608e9db8c842a3a7de92e.50564ba0.jpg" alt="图片"/></p><p>从hexdump显示的信息中，你能看到一些可以阅读的字符，比如“java/lang/Object”、&quot;java/lang/System&quot;等等，这些是常量表中的内容。还有一些内容显然不是字符，没法在屏幕上显示，所以hexdump就用一个.号来表示。其中某些字节，代表的是指令，我在图中把代表foo函数、main函数和构造函数的指令标注了出来，这些都是。用于运行的字节码指令，其他都是一些符号表等描述性的信息。</p><p>通过上图，你还能得到一个直观的印象：<strong>字节码文件并不都是由指令构成的</strong>。</p><p>没错，指令只是一个程序文件的一部分。除了指令以外，在字节码文件中还要存储不少其他内容，才能保证程序的正常运行，比如类和方法的符号信息、字符串和数字常量，等等。至于字节码文件的格式，是由字节码的规范来规定的，你有兴趣的话，可以按照规范生成这样的字节码文件。这样的话，我们的程序就可以在JVM上运行了。</p><p>不过，我现在不想陷入字节码文件格式的细节里，而是想用自己的方式生成字节码文件，够支持现在的语言特性，能够在我们自己的虚拟机上运行就行了。</p><p>上面这张图显示的字节码文件不是很容易阅读和理解。所以，我们用javap命令把它转化成文本格式来看看。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">javap -v A.class &gt; A.bc</span></div></pre></div><p>在这个新生成的文件里，我们可以清晰地看到每个函数的定义以及指令，我也在图里标注了主要的指令的含义。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagec9a1c90344b05e25ffae95a2c3e9e1a804a1.0f9d2388.jpg" alt="图片" title="文本格式的字节码文件"/></p><p>看到这个字节码文件的内容，你可能会直观地觉得：这看上去跟我们的高级语言也没有那么大的区别嘛。程序照样划分成几个函数，只不过每个函数里的语句变成了栈机的指令而已，函数之间照样需要互相调用。</p><p>实际上也确实没错。字节码文件里本来就存储了各个类和方法的符号信息，相当于保存了高级语言里的主体框架。当然，每个方法体里的代码就看不出if语句、循环语句这样的结构了，而是变成了字节码的指令。</p><p>通过研究这些指令，加上查阅<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/specs/jvms/se12/html/jvms-6.html">JVM规则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中对于字节码的规定，你会发现为了实现上面示例代码中的功能，我们目前只需要这几个指令就够了：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage6020608cdfd47efe1e162e8bd7ca88f1d420.392767f7.jpg" alt="图片"/></p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage55f655334d4a30a41ed87bf7bc82c64c9ef6.d5509781.jpg" alt="图片" title="常数入栈指令"/></p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagee58be52ef425d612381fe33628818c75c68b.d4fb3eee.jpg" alt="图片" title="二元运算指令，以及函数调用和返回指令"/></p><p>你先花一两分钟看一下这些指令，看上去挺多，其实可以分为几组。</p><p>首先是iload系列，这是把指定下标的本地变量入栈。注意，变量的下标是由声明的顺序决定的，参数也算本地变量，并且排在最前面。所以，iload 0的意思，就是把第一个参数入栈。如果没有参数，就是把第一个本地变量入栈。</p><p>iload后面的那几个指令，是压缩格式的指令，也就是利用指令末尾富余的位，把操作数和指令压缩在了一起，这样可以少一个字节码，能够缩小最后生成的字节码文件的大小。从这里面，你能借鉴到字节码设计的一些好的实践。所以你看，学习成熟的设计是有好处的吧？</p><p>第二组是istore系列，它做的工作刚好跟iload相反，是把栈顶的值存到指定下标的变量里去。</p><p>第三组，是对常数做入栈的操作。对于0~5这几个数字，Java字节码也是提供了压缩格式的指令。对于8位整数（-128~127），使用bipush指令。对于16位整数（-32768~32767），使用sipush指令。而对于更大的常数，则要使用ldc指令，从常量池里去取。</p><p>第四组，是几个二元运算的指令。它们都是从栈里取两个操作数，计算完毕之后，再压回栈里。</p><p>最后一组指令，是函数调用和返回的指令。函数调用的时候，也是从栈里取参数。返回值呢，则压回栈里。</p><p>通过这些指令，我们就完全能够实现一些基本的功能了，之后我们再根据需要添加更多的指令就好。</p><p>现在，我们把这些指令做成枚举值，方便程序使用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * 指令的编码</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    enum OpCode{</span></div><div class="token-line"><span class="token plain">        iconst_0= 0x03,</span></div><div class="token-line"><span class="token plain">        iconst_1= 0x04,</span></div><div class="token-line"><span class="token plain">        iconst_2= 0x05,</span></div><div class="token-line"><span class="token plain">        iconst_3= 0x06,</span></div><div class="token-line"><span class="token plain">        iconst_4= 0x07,</span></div><div class="token-line"><span class="token plain">        iconst_5= 0x08,</span></div><div class="token-line"><span class="token plain">        bipush  = 0x10,  //8位整数入栈</span></div><div class="token-line"><span class="token plain">        sipush  = 0x11,  //16位整数入栈</span></div><div class="token-line"><span class="token plain">        iload   = 0x15,  //本地变量入栈</span></div><div class="token-line"><span class="token plain">        iload_0 = 0x1a,</span></div><div class="token-line"><span class="token plain">        iload_1 = 0x1b,</span></div><div class="token-line"><span class="token plain">        iload_2 = 0x1c,</span></div><div class="token-line"><span class="token plain">        iload_3 = 0x1d,</span></div><div class="token-line"><span class="token plain">        istore  = 0x36,</span></div><div class="token-line"><span class="token plain">        istore_0= 0x3b,</span></div><div class="token-line"><span class="token plain">        istore_1= 0x3c,</span></div><div class="token-line"><span class="token plain">        istore_2= 0x3d,</span></div><div class="token-line"><span class="token plain">        istore_3= 0x3e,</span></div><div class="token-line"><span class="token plain">        iadd    = 0x60,</span></div><div class="token-line"><span class="token plain">        isub    = 0x64,</span></div><div class="token-line"><span class="token plain">        imul    = 0x68,</span></div><div class="token-line"><span class="token plain">        idiv    = 0x6c,</span></div><div class="token-line"><span class="token plain">        ireturn = 0xac,</span></div><div class="token-line"><span class="token plain">        return  = 0xb1,</span></div><div class="token-line"><span class="token plain">        invokestatic= 0xb8, //调用函数</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，我们通过全盘照抄的方式，“设计”出了自己所需要的字节码。不过这些都只是指令的部分。还要有常量池的部分，我们在下面使用到的时候再去设计。</p><p>接下来，我们来生成自己的字节码。</p><h2 id="生成字节码"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#生成字节码"><span class="icon icon-link"></span></a>生成字节码</h2><p>生成栈机的字节码是比较简单的。为什么呢？因为栈机的字节码基本上跟AST是同构的，通过深度优先的顺序遍历AST就可以实现。相对来说，生成寄存器机的指令的算法就要稍微绕一点，我们也会在后面的课程中体会到。</p><p>怎么来深度优先地遍历AST、生成栈机的字节码呢？以“3+a”这样一个简单的表达式为例，我们处理的顺序依次是字面量3、变量a和+号。</p><p>首先来处理字面量。处理整型字面量的时候，我们需要根据整数的不同长度，分别使用不同的常量指令。其中的一个细节是，当整数是16位时，操作数要拆成两个字节。而当大于16位时，我们干脆就把字面量放在常量池里，操作数只是该常数在常量池的索引值。</p><p>这里的处理你可以参照下面这个代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">visitIntegerLiteral(integerLiteral: IntegerLiteral):any{</span></div><div class="token-line"><span class="token plain">        let ret:number[] = [];</span></div><div class="token-line"><span class="token plain">        let value = integerLiteral.value;</span></div><div class="token-line"><span class="token plain">        //0-5之间的数字，直接用快捷指令</span></div><div class="token-line"><span class="token plain">        if (value &gt;= 0 &amp;&amp; value &lt;= 5) {</span></div><div class="token-line"><span class="token plain">            switch (value) {</span></div><div class="token-line"><span class="token plain">                case 0:</span></div><div class="token-line"><span class="token plain">                    ret.push(OpCode.iconst_0);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                ...省略1、2、3、4的情况</span></div><div class="token-line"><span class="token plain">                case 5:</span></div><div class="token-line"><span class="token plain">                    ret.push(OpCode.iconst_5);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //如果是8位整数，用bipush指令，直接放在后面的一个字节的操作数里就行了</span></div><div class="token-line"><span class="token plain">        else if (value &gt;= -128 &amp;&amp; value &lt;128){</span></div><div class="token-line"><span class="token plain">            ret.push(OpCode.bipush);</span></div><div class="token-line"><span class="token plain">            ret.push(value);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //如果是16位整数，用sipush指令</span></div><div class="token-line"><span class="token plain">        else if (value &gt;= -32768 &amp;&amp; value &lt;32768){</span></div><div class="token-line"><span class="token plain">            ret.push(OpCode.sipush);</span></div><div class="token-line"><span class="token plain">            //要拆成两个字节</span></div><div class="token-line"><span class="token plain">            ret.push(value &gt;&gt; 8);</span></div><div class="token-line"><span class="token plain">            ret.push(value &amp; 0x00ff);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //大于16位的，采用ldc指令，从常量池中去取</span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            //把value值放入常量池。</span></div><div class="token-line"><span class="token plain">            this.module.consts.push(value); </span></div><div class="token-line"><span class="token plain">            ret.push(this.module.consts.length -1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return ret;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接着来处理变量a。在处理变量的时候，我们要区分左值和右值的情况。在“3+a”这个表达式中，a是个右值，我们需要取出a的值，也就是要生成iload指令。但对于“a=3”这样的表达式，a是个左值，这个时候返回a的符号即可，在处理赋值运算的时候再生成istore指令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * 左值的情况，返回符号。否则，生成iload指令。</span></div><div class="token-line"><span class="token plain">     * @param v </span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    visitVariable(v:Variable):any{</span></div><div class="token-line"><span class="token plain">        if (v.isLeftValue){</span></div><div class="token-line"><span class="token plain">            return v.sym;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            return this.getVariableValue(v.sym);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 生成获取本地变量值的指令</span></div><div class="token-line"><span class="token plain">     * @param varName </span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    private getVariableValue(sym:VarSymbol|null):any{</span></div><div class="token-line"><span class="token plain">        if (sym != null){</span></div><div class="token-line"><span class="token plain">            let code:number[] = [];  //生成的字节码</span></div><div class="token-line"><span class="token plain">            //本地变量的下标</span></div><div class="token-line"><span class="token plain">            let index = this.functionSym?.vars.indexOf(sym);</span></div><div class="token-line"><span class="token plain">            assert(index != -1, &quot;生成字节码时（获取变量的值），在函数符号中获取本地变量下标失败！&quot;);</span></div><div class="token-line"><span class="token plain">            //根据不同的下标生成指令，尽量生成压缩指令</span></div><div class="token-line"><span class="token plain">            switch (index){</span></div><div class="token-line"><span class="token plain">                case 0:</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iload_0);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case 1:</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iload_1);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case 2:</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iload_2);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case 3:</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iload_3);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                default:</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iload);    </span></div><div class="token-line"><span class="token plain">                    code.push(index as number);               </span></div><div class="token-line"><span class="token plain">            }            </span></div><div class="token-line"><span class="token plain">            return code;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，我们要对加减乘除这些二元运算来生成代码，我们可以先为左右子树分别生成代码，再把加减乘除的运算指令放在最后。注意，赋值运算的处理逻辑是不同的，它要生成istore指令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">visitBinary(bi:Binary):any{</span></div><div class="token-line"><span class="token plain">        let code:number[];</span></div><div class="token-line"><span class="token plain">        let code1 = this.visit(bi.exp1);</span></div><div class="token-line"><span class="token plain">        let code2 = this.visit(bi.exp2);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ////1.处理赋值</span></div><div class="token-line"><span class="token plain">        if (bi.op == Op.Assign){</span></div><div class="token-line"><span class="token plain">            let varSymbol = code1 as VarSymbol; </span></div><div class="token-line"><span class="token plain">            //加入右子树的代码</span></div><div class="token-line"><span class="token plain">            code = code2;</span></div><div class="token-line"><span class="token plain">            //加入istore代码</span></div><div class="token-line"><span class="token plain">            code = code.concat(this.setVariableValue(varSymbol));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ////2.处理其他二元运算</span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            //加入左子树的代码</span></div><div class="token-line"><span class="token plain">            code = code1;</span></div><div class="token-line"><span class="token plain">            //加入右子树的代码</span></div><div class="token-line"><span class="token plain">            code = code.concat(code2);</span></div><div class="token-line"><span class="token plain">            //加入运算符的代码</span></div><div class="token-line"><span class="token plain">            switch(bi.op){</span></div><div class="token-line"><span class="token plain">                case Op.Plus: //&#x27;+&#x27;</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.iadd);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case Op.Minus: //&#x27;-&#x27;</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.isub);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case Op.Multiply: //&#x27;*&#x27;</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.imul);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                case Op.Divide: //&#x27;/&#x27;</span></div><div class="token-line"><span class="token plain">                    code.push(OpCode.idiv);</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                default:</span></div><div class="token-line"><span class="token plain">                    console.log(&quot;Unsupported binary operation: &quot; + bi.op);</span></div><div class="token-line"><span class="token plain">                    return [];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return code;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，到此这里，我们对处理基本的表达式就没有问题了。接下来，我们再增加与函数调用和返回有关的指令。</p><p>在进行函数调用的时候，我们要依次生成与参数计算有关的指令，最后生成invokestatic指令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let code:number[] = [];</span></div><div class="token-line"><span class="token plain">    //1.依次生成与参数计算有关的指令</span></div><div class="token-line"><span class="token plain">    for(let param of functionCall.paramValues){</span></div><div class="token-line"><span class="token plain">        let code = this.visit(param);</span></div><div class="token-line"><span class="token plain">        if (typeof code == &#x27;object&#x27;){</span></div><div class="token-line"><span class="token plain">            code = code.concat(code as number[]);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //2.生成invoke指令</span></div><div class="token-line"><span class="token plain">    let index = this.module.consts.indexOf(functionCall.sym);</span></div><div class="token-line"><span class="token plain">    code.push(OpCode.invokestatic);</span></div><div class="token-line"><span class="token plain">    code.push(index&gt;&gt;8);</span></div><div class="token-line"><span class="token plain">    code.push(index);</span></div><div class="token-line"><span class="token plain">    return code;</span></div></pre></div><p>然后，在处理return语句的时候，也要注意，我们要根据是否有返回值，分别生成ireturn和return指令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let code:number[] = [];</span></div><div class="token-line"><span class="token plain">    //1.为return后面的表达式生成代码</span></div><div class="token-line"><span class="token plain">    if(returnStatement.exp != null){</span></div><div class="token-line"><span class="token plain">        let code1 = this.visit(returnStatement.exp);</span></div><div class="token-line"><span class="token plain">        if (typeof code1 == &#x27;object&#x27;){</span></div><div class="token-line"><span class="token plain">            code = code.concat(code1 as number[]);</span></div><div class="token-line"><span class="token plain">            //生成ireturn代码</span></div><div class="token-line"><span class="token plain">            code.push(OpCode.ireturn);</span></div><div class="token-line"><span class="token plain">            return code;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    else{</span></div><div class="token-line"><span class="token plain">        //2.生成return代码，返回值是void</span></div><div class="token-line"><span class="token plain">        code.push(OpCode.return);</span></div><div class="token-line"><span class="token plain">        return code;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，我们已经能够顺利的生成字节码了。生成字节码以后，接下来就只剩最后一步了：实现一个虚拟机，让这些字节码真正运行起来！</p><h2 id="实现一个typescript版本的虚拟机"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#实现一个typescript版本的虚拟机"><span class="icon icon-link"></span></a>实现一个TypeScript版本的虚拟机</h2><p>如果你是学习Java的同学，那你在面试的时候肯定经常会被问到与虚拟机有关的知识点。你也会根据自己了解的知识，对操作数栈、常量池等发表一通见解。但是，你心里多多少少对这些概念还会隔着一层面纱。</p><p>直到你自己亲自动手实现一遍，哪怕只是实现一个原型系统，你对这些概念，以及对虚拟机到底是如何运行的，才会有真真切切的理解。所以，我鼓励你动手实现一遍。而且，我可以告诉你，真的花不了多少时间。如果你看看我给出的示例代码，其实就是一个大函数，针对不同的字节码指令做处理而已。</p><p>不过，为了便于你理解代码，我还是先画一个虚拟机的示意图。我们这个简单的虚拟机主要涉及几个对象：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage76a076a4640bbe5c0d394c1ed8e330c214a0.86b155ca.jpg" alt="图片"/></p><p>**首先是模块。**模块代表了我们的程序，模块里最重要的就是一个常量表。常量表中的常量包含字符串常量、数字常量和函数符号。而函数符号里有一个bytecode属性，保存了这个函数的字节码。这样，我们就可以找到函数的代码并运行它们了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">export class BCModule{</span></div><div class="token-line"><span class="token plain">      //常量</span></div><div class="token-line"><span class="token plain">      consts:any[] = [];</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      //入口函数</span></div><div class="token-line"><span class="token plain">      _main:FunctionSymbol|null = null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>**然后是运行程序的栈机。**栈机里最重要的数据结构是一个调用栈，在AST解释器里也有类似的数据结构。调用栈是由栈桢构成的，在执行每个函数的时候，都需要在栈顶新加一个栈桢，而在退出函数的时候，就会弹出这个函数的栈桢。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//栈机</span></div><div class="token-line"><span class="token plain">    export class VM{</span></div><div class="token-line"><span class="token plain">        //调用栈</span></div><div class="token-line"><span class="token plain">        callStack:StackFrame[]=[];</span></div><div class="token-line"><span class="token plain">        //执行一个模块</span></div><div class="token-line"><span class="token plain">        execute(bcModule:BCModule):number{</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你要注意，栈桢是一个关键的数据结构，它用来保存每个函数运行时所需要保存的状态信息。每个栈桢里又有几个关键的组成部分。</p><ul><li>操作数栈：用来保存函数执行过程中各个指令所需要用到的操作数；</li><li>存放本地变量的数组：可以在这里存取变量值；</li><li>返回地址：也是在调用子函数的时候，告诉子函数返回以后，从哪条代码接着运行。</li></ul><p>栈机里的execute方法，就是虚拟机的核心执行引擎。下面我摘一些有代表性的代码给你讲一下，你先看一下示例代码的结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//一直执行代码，直到遇到return语句</span></div><div class="token-line"><span class="token plain">    let opCode = code[codeIndex];</span></div><div class="token-line"><span class="token plain">    while(true){</span></div><div class="token-line"><span class="token plain">        switch (opCode){</span></div><div class="token-line"><span class="token plain">            case OpCode.iconst_0: //加载常量</span></div><div class="token-line"><span class="token plain">                frame.oprandStack.push(0);</span></div><div class="token-line"><span class="token plain">                opCode = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            case OpCode.sipush:  //加载32位常量，需要取出2个字节</span></div><div class="token-line"><span class="token plain">                let byte1 = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                let byte2 = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                frame.oprandStack.push(byte1&lt;&lt;8|byte2); </span></div><div class="token-line"><span class="token plain">                opCode = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            case OpCode.iload_0: //从变量里取值</span></div><div class="token-line"><span class="token plain">                frame.oprandStack.push(frame.localVars[0]);</span></div><div class="token-line"><span class="token plain">                opCode = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            case OpCode.istore_0: //给变量赋值</span></div><div class="token-line"><span class="token plain">                frame.localVars[0] = frame.oprandStack.pop();</span></div><div class="token-line"><span class="token plain">                opCode = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            case OpCode.iadd:     //加减乘除</span></div><div class="token-line"><span class="token plain">                frame.oprandStack.push(frame.oprandStack.pop() + frame.oprandStack.pop());</span></div><div class="token-line"><span class="token plain">                opCode = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可能马上会注意到，<strong>整个程序执行的过程就是一个大的while循环</strong>。</p><p>几乎所有的虚拟机的核心执行引擎都是这么写的，因为程序的执行过程就是不停地读取指令，然后根据指令做相应的动作。其中的代码计数器，一直指向下一个要执行的指令的位置。由于指令的种类比较多，所以switch后面会罗列很多个case，代码也会很长。你用电脑看这些代码的话，可能要翻很多屏。</p><p>虽然这个函数的代码很长，我们一般也不会把它拆成多个函数。为什么呢？这似乎违背了通常的编程理念呀。通常我们都不会编写太长的函数，这不容易阅读，也不容易维护。</p><p>但事情总有例外。对于虚拟机的执行引擎来说，性能上的考虑是第一位的。执行一个指令，可能开销并不大。但如果执行这条指令要调用一个专门的函数，那函数调用的额外开销会比执行指令本身的开销都大，那显然就不合理了，这也是我们为什么弃用AST解释器的原因。</p><p>我们这个示例代码中体现了加载常量、加载变量、保存变量和执行加减乘除的运算的实现方式。你能通过这些代码，再一次验证栈机的工作原理，这里所有操作都是围绕着操作数栈来进行的。</p><p>而函数的调用和返回，则显得复杂一点。这两部分代码，也有助于你更加细致的了解栈桢的使用方式。</p><p>首先我们来看看函数调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">case OpCode.invokestatic:</span></div><div class="token-line"><span class="token plain">        //从常量池找到被调用的函数</span></div><div class="token-line"><span class="token plain">        byte1 = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">        byte2 = code[++codeIndex];</span></div><div class="token-line"><span class="token plain">        let functionSym = bcModule.consts[byte1&lt;&lt;8|byte2] as FunctionSymbol;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //设置返回值地址，为函数调用的下一条指令</span></div><div class="token-line"><span class="token plain">        frame.returnIndex = codeIndex;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //创建新的栈桢</span></div><div class="token-line"><span class="token plain">        let lastFrame = frame;</span></div><div class="token-line"><span class="token plain">        frame = new StackFrame(functionSym);</span></div><div class="token-line"><span class="token plain">        this.callStack.push(frame);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //传递参数</span></div><div class="token-line"><span class="token plain">        let paramCount = (functionSym.decl as FunctionDecl).callSignature.params.length;</span></div><div class="token-line"><span class="token plain">        for(let i = paramCount -1; i&gt;= 0; i--){</span></div><div class="token-line"><span class="token plain">            frame.localVars[i] = lastFrame.oprandStack.pop();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //设置新的code、codeIndex和oPCode</span></div><div class="token-line"><span class="token plain">        if (frame.funtionSym.bytecode !=null){</span></div><div class="token-line"><span class="token plain">            //切换到被调用函数的代码</span></div><div class="token-line"><span class="token plain">            code = frame.funtionSym.bytecode;</span></div><div class="token-line"><span class="token plain">            //代码指针归零</span></div><div class="token-line"><span class="token plain">            codeIndex = 0;</span></div><div class="token-line"><span class="token plain">            opCode = code[codeIndex];</span></div><div class="token-line"><span class="token plain">            continue;</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>在函数调用的时候，我们要完成这几项工作：</p><ul><li>设置返回地址，被调用的函数在执行return指令的时候，会回到这个位置；</li><li>为被调用的函数生成新的栈桢，并加到调用栈中；</li><li>从操作数栈中取出参数的值，并赋给新的栈桢，因为参数也算作本地变量，因此只需要对新栈桢的前几个本地变量赋值就可以了；</li><li>把代码切换到被调用函数的代码，并且把代码计数器设置为0，也就是从第一个字节码指令开始执行。</li></ul><p>而函数返回是函数调用的逆向操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">case OpCode.ireturn:</span></div><div class="token-line"><span class="token plain">    case OpCode.return:</span></div><div class="token-line"><span class="token plain">        //确定返回值</span></div><div class="token-line"><span class="token plain">        let retValue = undefined;</span></div><div class="token-line"><span class="token plain">        if(opCode == OpCode.ireturn){</span></div><div class="token-line"><span class="token plain">            retValue = frame.oprandStack.pop();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //弹出栈桢，返回到上一级函数，继续执行</span></div><div class="token-line"><span class="token plain">        this.callStack.pop();</span></div><div class="token-line"><span class="token plain">        if (this.callStack.length == 0){ //主程序返回，结束运行</span></div><div class="token-line"><span class="token plain">            return 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else { //返回到上一级调用者</span></div><div class="token-line"><span class="token plain">            frame = this.callStack[this.callStack.length-1];</span></div><div class="token-line"><span class="token plain">            //设置返回值到上一级栈桢</span></div><div class="token-line"><span class="token plain">            // frame.retValue = retValue;</span></div><div class="token-line"><span class="token plain">            if(opCode == OpCode.ireturn){</span></div><div class="token-line"><span class="token plain">                frame.oprandStack.push(retValue);</span></div><div class="token-line"><span class="token plain">            }    </span></div><div class="token-line"><span class="token plain">            //设置新的code、codeIndex和oPCode</span></div><div class="token-line"><span class="token plain">            if (frame.funtionSym.byteCode !=null){</span></div><div class="token-line"><span class="token plain">                //切换到调用者的代码</span></div><div class="token-line"><span class="token plain">                code = frame.funtionSym.byteCode;</span></div><div class="token-line"><span class="token plain">                //设置指令指针为返回地址，也就是调用该函数的下一条指令</span></div><div class="token-line"><span class="token plain">                codeIndex = frame.returnIndex;</span></div><div class="token-line"><span class="token plain">                opCode = code[codeIndex];</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            else{</span></div><div class="token-line"><span class="token plain">                console.log(&quot;Can not find code for &quot;+ frame.funtionSym.name);</span></div><div class="token-line"><span class="token plain">                return -1;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        continue;</span></div></pre></div><p>函数返回时，我们需要完成下面这几项工作：</p><ul><li>设置返回值，如果确实有一个返回值，那么就从当前操作数栈中取出来，返回值加载到上一级栈桢里的操作数栈；</li><li>从调用栈中弹出当前栈桢；</li><li>把代码切换成调用者的代码，并且把代码指针设置成函数调用指令的下一条指令，继续函数调用之后的工作；</li><li>这里还有一个特殊情况，执行到return指令的时候，你会发现当前栈桢之上，再也没有上一级栈桢了。这说明当前所在的函数已经是最顶层了，也就是我们的编译器内部的_main()函数。这个时候，return指令就会结束整个while循环，也意味着整个程序运行结束。</li></ul><p>好了，这就是函数调用和返回的过程。通过这个过程，你会发现这两类指令其实是遵循了一些共同的约定。</p><p>这些约定包括：我们传参数的时候，把参数放在哪里？函数返回的时候，又把返回值放在哪里？还有，调用函数的时候，我们应该在一个双方都知道的位置设置返回地址，以便函数返回后调到这个地址继续执行。</p><p>这里，你又学到一个概念，叫做<strong>调用约定（Calling Convention）</strong>。计算机语言的设计者，可以设计自己的调用约定，这样用自己的编译器编译出来的模块，都能互相调用。但如果一种语言想调用另一种语言编写的模块，那么它们必须遵循相同的调用约定，或者要在不同的调用约定之间做转换。比如，Java调用C语言写的模块，要使用JNI接口，就是要完成这种调用约定的转换。</p><p>跟调用约定差不多的一个概念叫做<strong>ABI（Application Binary Interface）</strong>。ABI这个名字更强调如何在二进制的层面上实现互相调用，以及二进制程序文件的格式，等等，所以更适合描述像C、C加加这些编译成二进制目标代码的情形。</p><p>好了，现在我们已经拥有了一个简化版的虚拟机了，你可以用它跑几个程序试一下。因为现在我们这个虚拟机还不支持if语句和循环语句，所以还不方便做性能测试。这个工作，我们放在下一节课再去做。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>好了，今天这节课到这里就结束了，让我们来简单回顾一下。</p><p>今天，我们设计并实现了一个简单的基于栈机的虚拟机，实现了我们在虚拟机领域0的突破。如果你认真跟着学完了这一节，我相信你一定会有很多收获。</p><p>首先，我们学了栈机的指令，通常包括加载常数、加载变量、保存变量、加减乘除、函数调用和返回这些，用这些指令就能让程序运行起来了。下一节课我们还会多学习一些指令，特别是分支指令。</p><p>第二，我们已经可以通过遍历AST的方式生成字节码。其中稍微有点难度的地方，是在访问变量节点的时候，要区分左值和右值，分别生成给变量赋值的代码和读取变量值的代码。</p><p>第三，在虚拟机里，我们用了BCModule这个数据结构来表示可被执行的程序。其实你把这个数据结构保存到文件里就是字节码文件了，它里面主要的内容就是一个常量表。常量表里除了字符串、数字这样的常规意义上的常数以外，最重要的还有函数符号，函数符号中包含了要运行的字节码。</p><p>第四，栈机的执行引擎是一个很大的循环，要依次执行每条指令，在这个过程中操作数栈会不停的压入数据、弹出数据。在调用函数和返回函数的时候，要建立栈桢和弹出栈桢。函数参数被设置到新栈桢的本地变量里，而返回值则被设置到上一级栈桢的操作数栈里，这就构成了函数之间的调用约定。</p><p>虽然我们目前是在虚拟机层面上了解这些概念，但是，即使是到了我们把程序编译成机器码的时候，这些基本概念仍然是差不多的。你现在学习的成果，会为后面的学习内容打下很好的基础。</p><p>在下一节课，我们将继续深化我们虚拟机。到时候它会在哪些方面取得突破呢？敬请期待吧！</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在这节课的BCModule中有一个常量表，为什么把函数符号也看做是常量呢？刨去其中的字节码，这些符号信息可能有什么潜在的用途呢？欢迎在留言区发表你的看法！</p><p>感谢你和我一起学习，欢迎你把我这节课分享给更多对字节码虚拟机感兴趣的朋友。我是宫文学，我们下节课见！</p><h2 id="课程资源"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08#课程资源"><span class="icon icon-link"></span></a>课程资源</h2><p><a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/tree/master/16-18">这节课的示例代码在这里！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 16:53:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-other2/umi.2006439a.js"></script>
  </body>
</html>
