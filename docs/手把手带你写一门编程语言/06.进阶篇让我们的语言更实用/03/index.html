<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-other2/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-other2";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>24｜增强编译器前端功能第3步：全面的集合运算 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></span><span>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></span><span>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-other2/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>大数据<ul><li><a href="/blog-other2/从0开始学大数据">从0开始学大数据</a></li></ul></li><li>架构师<ul><li><a href="/blog-other2/sre实战手册">sre实战手册</a></li><li><a href="/blog-other2/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-other2/深入浅出云计算">深入浅出云计算</a></li><li><a href="/blog-other2/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-other2/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>工作生活<ul><li><a href="/blog-other2/机器学习40讲">机器学习40讲</a></li><li><a href="/blog-other2/职场求生攻略">职场求生攻略</a></li></ul></li><li>杂谈<ul><li><a href="/blog-other2/aI技术内参">aI技术内参</a></li><li><a href="/blog-other2/人工智能基础课">人工智能基础课</a></li><li><a href="/blog-other2/反爬虫兵法演绎20讲">反爬虫兵法演绎20讲</a></li><li><a href="/blog-other2/实用密码学">实用密码学</a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/深入浅出区块链">深入浅出区块链</a></li><li><a href="/blog-other2/说透区块链">说透区块链</a></li><li><a href="/blog-other2/超级访谈对话汤峥嵘">超级访谈对话汤峥嵘</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-other2/手把手带你写一门编程语言">手把手带你写一门编程语言</a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词">01.开篇词</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/01"><span>开篇词｜让我们来写一门计算机语言吧</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/01.开篇词/02"><span>课前热身｜开始学习之前我们要准备什么？</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来">02.起步篇让一门超简单的语言跑起来</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/01"><span>01｜实现一门超简单的语言最快需要多久？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/02"><span>02｜词法分析：识别Token也可以很简单吗？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/03"><span>03｜支持表达式：解析表达式和解析语句有什么不同？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/04"><span>04｜如何让我们的语言支持变量和类型？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/05"><span>05｜函数实现：是时候让我们的语言支持函数和返回值了</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/06"><span>06｜怎么支持条件语句和循环语句？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/07"><span>07｜怎么设计属于我们自己的虚拟机和字节码？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/08"><span>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/09"><span>09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/10"><span>10｜基于C语言的虚拟机（一）：实现一个简单的栈机</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/11"><span>11｜基于C语言的虚拟机（二）：性能增长10倍的秘密</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/12"><span>12｜物理机上程序运行的硬件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/13"><span>13｜物理机上程序运行的软件环境是怎么样的？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/14"><span>14｜汇编代码学习（一）：熟悉CPU架构和指令集</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/15"><span>15｜汇编语言学习（二）：熟悉X86汇编代码</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/16"><span>16｜生成本地代码第1关：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/17"><span>17｜生成本地代码第2关：变量存储、函数调用和栈帧维护</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/18"><span>18｜生成本地代码第3关：实现完整的功能</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/19"><span>19｜怎么实现一个更好的寄存器分配算法：原理篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/20"><span>20｜怎么实现一个更好的寄存器分配算法：实现篇</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/02.起步篇让一门超简单的语言跑起来/21"><span>21｜加深对栈的理解：实现尾递归和尾调用优化</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试">03.期中测试</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/03.期中测试/01"><span>期中测试｜快来检验你在起步篇的学习成果吧</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享">04.用户分享</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/04.用户分享/01"><span>“他山之石”｜Sugar：这门课你可以试试这么学</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐">05.不定时加餐</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/05.不定时加餐/01"><span>“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用">06.进阶篇让我们的语言更实用</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/01"><span>22｜增强编译器前端功能第1步：再识数据流分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/02"><span>23｜增强编译器前端功能第2步：增强类型体系</span></a></li><li><a aria-current="page" class="active" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03"><span>24｜增强编译器前端功能第3步：全面的集合运算</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/04"><span>25｜增强编译器前端功能第4步：综合运用多种语义分析技术</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/05"><span>26｜增强更丰富的类型第1步：如何支持浮点数？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/06"><span>27｜增加更丰富的类型第2步：如何支持字符串？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/07"><span>28｜增加更丰富的类型第3步：支持数组</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/08"><span>29｜面向对象编程第1步：先把基础搭好</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/09"><span>30｜面向对象编程第2步：剖析一些技术细节</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/10"><span>31｜面向对象编程第3步：支持继承和多态</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/11"><span>32｜函数式编程第1关：实现高阶函数</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/12"><span>33｜函数式编程第2关：实现闭包特性</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/13"><span>34｜内存管理第1关：Arena技术和元数据</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/14"><span>35｜内存管理第2关：实现垃圾回收</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高">07.优化篇让程序的性能更高</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/01"><span>36｜节点之海：怎么生成基于图的IR？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/02"><span>37 | 从AST到IR：体会数据流和控制流思维</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/03"><span>38｜中端优化第1关：实现多种本地优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/04"><span>39｜中端优化第2关：全局优化要怎么搞？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/05"><span>40｜中端优化第3关：一起来挑战过程间优化</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/07.优化篇让程序的性能更高/06"><span>41｜后端优化：生成LIR和指令选择</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途">08.展望篇实现自主语言的征途</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/01"><span>42｜到这里，我们的收获和未尽的工作有哪些？</span></a></li><li><a href="/blog-other2/手把手带你写一门编程语言/08.展望篇实现自主语言的征途/02"><span>期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语">09.结束语</a><ul><li><a href="/blog-other2/手把手带你写一门编程语言/09.结束语/01"><span>结束语｜等待你大展身手的那些领域</span></a></li></ul></li><li><a href="/blog-other2/手把手带你写一门编程语言/summary">手把手带你写一门编程语言</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="类型计算的场景" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#类型计算的场景"><span>类型计算的场景</span></a></li><li title="子类型和重叠的判断" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#子类型和重叠的判断"><span>子类型和重叠的判断</span></a></li><li title="交集、并集和补集的计算场景" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#交集并集和补集的计算场景"><span>交集、并集和补集的计算场景</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#课程小结"><span>课程小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#思考题"><span>思考题</span></a></li><li title="资源链接" data-depth="2"><a href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#资源链接"><span>资源链接</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24增强编译器前端功能第3步全面的集合运算"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#24增强编译器前端功能第3步全面的集合运算"><span class="icon icon-link"></span></a>24｜增强编译器前端功能第3步：全面的集合运算</h1><p>你好，我是宫文学。</p><p>在上一节课，我们扩展了我们语言的类型体系，还测试了几个简单的例子。从中，我们已经能体会出一些TypeScript类型体系的特点了。</p><p>不过，TypeScript的类型体系其实比我们前面测试的还要强大得多，能够在多种场景下进行复杂的类型处理。</p><p>今天这节课，我们会通过多个实际的例子，来探索TypeScript的类型处理能力。并且，在这个过程中，你还会进一步印证我们上一节课的一个知识点，就是<strong>类型计算实际上就是集合运算</strong>。在我们今天的这些例子中，你会见到多种集合运算，包括子集判断、重叠判断，以及交集、并集和补集的计算。</p><p>首先，让我们看几个例子，来理解一下类型计算的使用场景。</p><h2 id="类型计算的场景"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#类型计算的场景"><span class="icon icon-link"></span></a>类型计算的场景</h2><p>我们先看第一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo1(age : number|null){</span></div><div class="token-line"><span class="token plain">        let age1 : string|number;</span></div><div class="token-line"><span class="token plain">        age1 = age;   //编译器在这里会检查出错误。</span></div><div class="token-line"><span class="token plain">        console.log(age1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子中，我们用到了age和age1两个变量，它们都采用了联合类型。一个是number|null，一个是string|number。</p><p>如果你用–strict选项来编译这个程序，那么tsc会报错：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagecc24cc57e718200cf6c9416fa2c89ca47424.1b187a4b.png" alt="图片"/></p><p>这个错误信息的意思是：类型number|null不能赋给类型string|number。具体来说，null是不能赋给string|number的。</p><p>这说明什么呢？这说明对于赋值语句，比如x = y来说，它会有一个默认要求，要求y的类型要么跟x一样，要么是x的子集才可以。我们把这个关系记做y.type &lt;= x.type。</p><p>那么，其他的二元运算，是不是也像赋值运算那样，需要一个类型是另一个类型的子集呢？</p><p>不是的。不同的运算，做类型检查的规则是不同的。比如，对于“==”和“!=”这两个运算符，只需要两个类型有交集就可以。你可以用tsc编译一下这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo2(age1 : number|null, age2:string|number){</span></div><div class="token-line"><span class="token plain">        if (age1 == age2){     //OK。只要两个类型有交集就可以。</span></div><div class="token-line"><span class="token plain">            console.log(&quot;same age!&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你会看到，编译器并不会报错。这说明，两个不同的类型，只要它们有交集，就可以进行等值和不等值比较。并且，即使age1的值是null，age2的值是一个字符串，等值比较仍然是有意义的，比较的结果是不相等。</p><p>那如果两个类型没有交集，会发生什么情况呢？我们看看下面的例子，参数x和y属于不同的类型，它们之间没有交集。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo3(x : number|null, y:string|boolean){</span></div><div class="token-line"><span class="token plain">        if (x == y){   //编译器报错：两个类型没有交集</span></div><div class="token-line"><span class="token plain">            console.log(&quot;x and y is the same&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这次，如果你用tsc去编译，即使不加–strict选项，编译器也会报错：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagec234c2d10ddc726929d1c67ee389bd251f34.01fbd84e.png" alt="图片"/></p><p>编译器会说，这个条件表达式会永远返回false，因为这两个类型没有交集。</p><p><strong>到此为止，我们就了解清楚等值比较的规则了，也就是要求两个类型有交集才可以，或者说两个类型要存在重叠。</strong></p><p>那其他的比较运算符，比如&gt;，&gt;=，&lt;，&lt;=，也遵循相同的规则吗？</p><p>我们把foo2中的==运算符改为&gt;=运算符，得到一个新的示例程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo4(age1 : number|null, age2:string|number){</span></div><div class="token-line"><span class="token plain">        if (age1 &gt;= age2){  //编译器报错</span></div><div class="token-line"><span class="token plain">            console.log(&quot;bigger age!&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们再把这个示例程序用tsc --strict模式编译一下，编译器也会报错：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimaged48ad4f943a7f0731b4b0ddc984c7752b68a.d7fa2cc5.png" alt="图片"/></p><p>这次报错的原因，是age1有可能取值为null，而null是不能做大小的比较的。这说明，有些类型是不能做大小比较的。</p><p>那什么类型之间可以做大小比较呢？number、string、boolean类型之间都是可以的。但object类型、undefined类型，就不可以做比较了。所以，如果我们把foo4示例程序中age1的类型中去掉null值之后，编译器就不会报错了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo5(age1 : number, age2:string|number){</span></div><div class="token-line"><span class="token plain">        if (age1 &gt;= age2){  //OK。</span></div><div class="token-line"><span class="token plain">            console.log(&quot;bigger age!&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>刚才我们总结了等值比较和大小比较做类型检查的规则。你还可以进一步研究一下加减乘除这几个运算的类型检查的规则，我这里也整理了一下。</p><p>首先是+号运算符。+号运算符有两个语义：一个是作为字符串的连接符使用，这时候类型检查的规则是，只要+号运算符一边的类型是string型的，那么另一边可以是任意的类型，因为任意的类型都可以转化成字符串；+号的另一个语义是做数字的算术运算，在这种情况下，运算符两边只能是数字类型，包括number类型和枚举类型。</p><p>其次是-号、*号和/号。它们做类型检查的规则，跟+号的第二个语义的规则是一样的，也就是运算符的两边只能是数字类型。</p><p>再进一步，你还可以研究一下逻辑运算符，也就是&amp;&amp;、||和!这几个运算符。这几个运算符要求操作数是boolean值的。不过，在TypeScript中，任意类型都可以转化为boolean值，包括string、number、object和undefined类型。这些类型中，有些值等价于true，而其他值等价于false。等价于false的值包括：数字0、对象null、空字符串、NaN，以及undefined。</p><p>所以，看来类型检查中涉及的语义规则，还真是挺丰富的。而要实现上面这些类型检查功能，关键点就是实现类型的计算。在上面的例子中，我们看到需要实现两个运算：<strong>LE运算和overlap运算，我们又把它们叫做子类型判断和重叠判断</strong>。</p><h2 id="子类型和重叠的判断"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#子类型和重叠的判断"><span class="icon icon-link"></span></a>子类型和重叠的判断</h2><p>我们这里提到了一个术语，子类型。什么是子类型呢？如果A是B的子类型，那意味着A的每个成员，也都是B的成员。如果采用集合的术语，这意味着A集合是B集合子集。</p><p>在学习面向对象的时候，你肯定知道子类和父类的概念，它们之间的关系就是子类型关系。我们举一个例子：我们都知道“人”是“哺乳动物”的子类，那么我们可以说任何一个“人”，都肯定是一个“哺乳动物”。“人”的集合是“哺乳动物”集合的子集。</p><p>不过，除了面向对象的子类关系外，还有其他的子类型，<strong>只要二者之间具有子集的关系就行</strong>。比如：</p><ul><li>类型“0|1”，也就是只能取0和1两个值的类型，它是number的子类型，也是“0|1|2”的子类型；</li><li>类型string，是“string|number”的子类型，也是“string|null”的子类型。</li></ul><p>实现子类型判断，你可以参考TypeUtil类的LE方法。它里面的运算规则比较多，我挑重点的和你解释一下：</p><p><strong>首先，我们要如何判断一个NamedType是另一个NamedType的子类型呢？</strong></p><p>对于string、number和boolean这些基础类型来说，它们都是并列的，相互之间没有子类型的关系。不过，由于后面我们会讲到面向对象特性，而面向对象中的类型之间是有子类型关系的，所以我这里预先做了准备。</p><p>你看看NamedType类的设计，会发现它有一个upperTypes属性，这里就存了该类型的多个父类型。所以，基于这个upperTypes属性，父类和子类就被关联到了一起，我们的编译器也就能够基于此来判断一个类型是否是另一个类型的子类型。</p><p>而且，在PlayScript中，我提供了Number的两个子类型，分别是Integer和Decimal，可以用来验证这个特性。在类型消解的时候，编译器会把整型字面量的类型标注为Integer的，而把浮点型字面量的类型标注为Decimal的。在赋值的时候，Integer和Decimal类型的值，都可以赋给number类型的变量。</p><p><strong>第二，如何判断一个值类型是否是某个NamedType的子类型呢？</strong></p><p>这个问题比较简单，我们对每个值类型都记录了它所属的NamedType基础类型。比如，整数值类型是Integer，所以整数的值类型一定是Integer的子类型。而Integer又是number的子类型，那么整数值类型也是number的子类型。</p><p><strong>第三，如何判断一个NamedType或ValueType是UnionType的子类型呢？</strong></p><p>你会看到，UnionType中有一个types数组，代表了多个类型的联合。如果一个NamedType或ValueType是UnionType中任何一个元素的子类型，那么它就是该UnionType的子类型。</p><p>**最后，我们如何判断一个UnionType是另一个UnionType的子类型呢？**比如“0|1”是否是“0| 1|2”的子类型，或者是否是“number|string”的子类型呢？</p><p>这就要求第一个UnionType类型的每个成员都得是第二个UnionType的子类型才可以。</p><p>好了，上面就是我们做子类型的检查的思路了。那第二个运算，检查类型之间是否有交集，或者说是否重叠，也可以借鉴类似的思路，算法上稍有区别。你参考下TypeUtil类的overlap方法就行。</p><p>在实现了子类型和overlap的检测以后，我们就能完成前面那些场景中的类型检查了。</p><p>不过，TypeScript做类型计算的能力不止于此，它还有些更强大的能力，这会用到其他的集合运算，包括交集、并集和补集的计算。</p><p>让我们通过这些新的场景来探索一下。</p><h2 id="交集并集和补集的计算场景"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#交集并集和补集的计算场景"><span class="icon icon-link"></span></a>交集、并集和补集的计算场景</h2><p>我们还是回到这节课的第一个例子程序来分析分析。在这个例子中，编译器不允许把age赋值给age1，因为age可能取值为null，不能赋值给“string|number”。</p><p>现在我们把这个例子改一下，加一句“age = 18;”，然后再给age1赋值，看看会发生什么变化：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo6(age : number|null){</span></div><div class="token-line"><span class="token plain">        let age1 : string|number;</span></div><div class="token-line"><span class="token plain">        age = 18;     //age的值域现在变成了一个值类型：18</span></div><div class="token-line"><span class="token plain">        age1 = age;   //这里编译器不再报错。</span></div><div class="token-line"><span class="token plain">        console.log(age1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看看这个例子程序，现在age的值是18。那么这时再把age的值赋给age2，编译器还会不会报错呢？</p><p>你肯定不希望编译器报错，因为现在age的值是一个number，不是null，所以肯定是可以赋给age1的呀。</p><p>确实如你所愿，tsc编译器这次没有再报错了。这个编译器真的是挺聪明的。</p><p>可是，这个编译器是如何做到这一点的呢？不是说age必须是age1的子类型吗？</p><p>**原来，TypeScript的编译器，结合数据流分析技术，随着程序的执行，可以动态地改变变量的值域，也就是取值范围。**比如，在“age = 18”这句之后，age的值域就变成了一个值类型18。如果用我们这个新的类型来做类型检查，自然就不会出错。</p><p>那如果我们再给age赋一个新值，让它等于null会怎样呢？你可以参考下面的例子程序。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo7(age : number|null){</span></div><div class="token-line"><span class="token plain">        let age1 : string|number;</span></div><div class="token-line"><span class="token plain">        age = 18;     //age的值域现在变成了一个值类型：18</span></div><div class="token-line"><span class="token plain">        age1 = age;   //OK。</span></div><div class="token-line"><span class="token plain">        age = null;   //age的值域现在变成了null</span></div><div class="token-line"><span class="token plain">        age1 = age;   //错误！</span></div><div class="token-line"><span class="token plain">        console.log(age1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个时候，age的值域变成了null。如果我们这个时候把age赋给age1，那么编译器就会报错。</p><p>除了赋值语句、变量初始化语句能够改变变量的值域以外，if语句中的条件，也会影响到变量的值域，你再看看下面的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo8(age : number|null){</span></div><div class="token-line"><span class="token plain">        let age1 : string|number;</span></div><div class="token-line"><span class="token plain">        if (age != null){   //age的值域现在是number</span></div><div class="token-line"><span class="token plain">            age1 = age;     //OK!</span></div><div class="token-line"><span class="token plain">            console.log(age1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else{               //age==null, 值域现在变成了null</span></div><div class="token-line"><span class="token plain">            console.log(&quot;age is empty!&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子中，if条件是“age!=null”。这个条件跟age原来的类型“number|null”相结合，就会求出if块中的age类型变成了“number”，把null这个选项去掉了。</p><p>这个过程是怎么实现的呢？</p><p>在这里，你可以把求age值域的过程看做是做集合运算的过程。在if条件中的表达式，会生成一个age的值域，这个值域是所有不等于null的值，我记做!null。这个值域跟原来age的值域“number|null”做交集运算，最后的结果就是number。我画了一张示意图，表示交集运算的过程，你可以看一下：</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimagede01de6f8581e7db8b981f8f19ffcfbce701.426e71e1.png" alt="图片"/></p><p>在这个示意图里，长方形的区域表示全集。全集里面有一个蓝色的圈，表示number集合。还有一个小点，表示null这个值，这两个部分都是蓝色的，代表了“number|null”。</p><p>而打斜线的区域，是在全集中抠去null那个点后剩余的部分，是<!-- -->{<!-- -->null<!-- -->}<!-- -->的补集，我记做!null。这两个集合的交集，就是代表number的那个圆圈。所以，这个圆圈既带有蓝色，又打了斜线。</p><p>在这里，你会发现，我们的算法又需要支持两个集合运算。第一个运算，是<strong>求交集运算</strong>。在这里，我们可以先来简单总结一下交集运算的规则：</p><p>**规则一：**对于两个NamedType，如果一个是另一个的子类型，那么交集就是子类型。在下图中，number和integer的交集是integer。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage184018236214b10511881e77ca8a6640ee40.206f1938.png" alt="图片"/></p><p>**规则二：**如果两个类型之间没有子类型关系，那么它们的交集就是空集。就像下图中的number和string。</p><p><img src="/blog-other2/static/httpsstatic001geekbangorgresourceimage1f6d1fa42c696233e4efcdd95018a5f4a46d.c7a9256f.png" alt="图片"/></p><p>在算法中，用什么来表示空集呢？在PlayScript的代码中，我用了一个特殊的NamedType，叫做Never，它对应了TypeScript中内置的类型never。关于never类型的介绍，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type">TypeScript手册中的内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>说完了NamedType之间求交集，你还可以进一步思考一下如何在NamedType、ValueType和UnionType之间互相求交集。总体上，遵循集合运算的规则就行了。</p><p>除了交集运算，还需要<strong>求补集</strong>。在前面的例子中，我们用到了null的补集。那如何表达null的补集呢？我用的方法，是在ValueType对象里加了一个isComplement属性。如果这个属性为true，就代表这个值对象其实是该值的补集。</p><p>除了值对象有补集，其实NamedType也可以有补集。比如，你在if条件中可以放“typeof age != ‘string’”这样的语句，这时候age的值域就是!string，也就是string的补集。</p><p>在上面的示例程序中，我们还有一个地方用到了补集，这就是计算else块中的值域的时候。在else块中，要对if条件生成的值域取补集，也就是把!null再做一次补集运算，得到的结果就是null。也就是说，在else块中，age的取值肯定是null。</p><p>现在我们就说完了求交集和补集这两个集合运算。不过，你可能马上又会想到，<strong>在集合运算里还有求并集的运算呀，那在我们类型计算里是不是也有这个场景呢？</strong></p><p>有的。如果我们把if条件复杂化一点，用上逻辑运算“||”，那么这个if条件形成的值域就是18|81。这里就做了一次求并集的运算，把18和81两个值类型并在了一起。我们让这个并集再跟“number|null”做交集运算，结果仍然是18|81。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function foo9(age : number|null){</span></div><div class="token-line"><span class="token plain">        if (age == 18 || age == 81){ //age的值域是 18|81</span></div><div class="token-line"><span class="token plain">            console.log(&quot;18 or 81&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else{                  //age的值域是 (number | null) &amp; !18 &amp; !81</span></div><div class="token-line"><span class="token plain">            console.log(&quot;age is empty!&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们把这个例子再往下深化分析一下。如果if块中age的值域是18|81，那么else块中是什么呢？那就是number|null中去掉18和81就可以了。</p><p>具体计算过程，是先对 18|81求补集，也就是!( 18|81) = !18 &amp; !81。其中&amp;是交集的意思。然后再跟(number|null)求交集，得到的结果是(number|null) &amp; !18 &amp; !81。</p><p>到这里，我们又必须引入另一个表示类型的对象，叫做IntersectionType，用于表示多个类型之间的交集。交集类型中，多个成员之间使用&amp;连接的。</p><p>并且，运用集合运算的知识，你还能意识到交集对象和联合对象之间是有转换关系的。UnionType的补集，就是一个IntersectionType，而IntersectionType的补集呢，则是UnionType。</p><p>那到目前为止，我们用于表示类型的对象体系就更加完善了。我们增加了一个新的类型，是IntersectionType。并且，我们还把ValueType和NamedType都加上了是否是补集的属性。</p><p>好了，求集合的补集、交集和并集等运算我们都讲过了。但对于刚才这个例子。我们还需要用数据流分析方法动态地求变量的值域。不过，今天的新知识点已经足够多了，我们还是把这个任务放到下一节课。在下一节课，我们会综合运用多种语义分析技术，来获得更强大的效果。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>在今天这节课，我们举了多个例子，示范了多个类型计算的场景。在这个过程中，我们接触到了个多种集合运算，包括子集判断、重叠判断、求补集、求交集和求并集。</p><p>第一，子集判断的典型场景是赋值运算。比如x=y语句，要求y的类型和x的类型相等，或者y的类型是x的类型的子集。如果y的类型是x的类型的子集，我们可以简单地说y是x的子类型。面向对象编程中的继承关系就是子类型的一种体现。</p><p>第二，重叠判断的典型场景是==和!=运算符。它们要求两边的类型有重叠的部分。如果没有重叠的部分，编译器就会报错。</p><p>第三，并集的使用场景，是if条件中带有逻辑运算||的情况，在下一节你还会看到另一个使用场景。</p><p>第四，交集的使用场景，一个是if条件中有逻辑运算&amp;&amp;的情况，另一个是If条件中得到的值域，与变量原来的值域求交集，得到if块中变量的值域。</p><p>第五，补集有多个使用场景，一个是针对!=运算符，第二个是if条件中使用!运算符，还有一个是求else块中的变量值域时。如果对UnionType求补集，我们会得到一个IntersectionType。</p><p>这节课的例子，你都可以通过node play example_type2.ts来运行。关于类型计算的实现，可以参考TypeChecker和TypeUtil两个类。</p><p>我们这节课的内容，全面地运用了集合计算，这也是TypeScript具备强大的类型处理能力的原因。很多现代语言的类型处理能力现在也变得越来越强，这背后的数学知识都是集合运算。所以，你一定要重视这个知识点。你要学会像这节课这样，分析在各种场景下，编译器到底是如何使用集合运算来做类型处理的。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在这节课，我们涉猎了很多集合运算的知识点，让整个类型处理变成了一个自洽的体系。今天的思考题，我们继续把这种类型计算的方式跟其他语言做一下对比。你在其他语言做见过对类型做交集、并集、补集、判断子集和判断重叠的运算吗？欢迎在留言区分享你的发现。</p><p>欢迎你把这节课分享给更多对类型计算感兴趣的朋友。我是宫文学，我们下节课见。</p><h2 id="资源链接"><a aria-hidden="true" tabindex="-1" href="/blog-other2/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03#资源链接"><span class="icon icon-link"></span></a>资源链接</h2><p>1.这节课的示例代码目录在<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/tree/master/24">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>！</p><p>2.主要看语义分析的代码(<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/24/semantic.ts#L505">semantic.ts<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)和类型体系的代码(<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/24/types.ts">types.ts<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)。</p><p>3.例子代码：<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/craft-a-language/blob/master/24/example_type2.ts">example_type2.ts<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/手把手带你写一门编程语言/06.进阶篇让我们的语言更实用/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 16:59:11</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-other2/umi.2006439a.js"></script>
  </body>
</html>
